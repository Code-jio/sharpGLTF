## 性能检测器

- [x] 配置模型渲染密度、个数

- [x] 可切换同种模型是否共享材质

- [x] 生成随机管道

- [x] 收集网格信息（面、材质、贴图数）

- [x] 视点半径范围外隐藏模型

- [x] 视锥体范围外隐藏模型

- [x] 统一渲染后的个体选取高亮及删除

- [x] 表格（模型的选染列表：占比）

- [x] 各管道间首尾相连

  



​	管道曲线的点位不会因为强制更新世界矩阵就会发生变化，做一定的位移后，点位依然是点位（由此生成的所有管道几何体，它的parmaters上的points都相同，所以不能以此生成管道，将其首尾连接起来）

​    1.所以得将这个曲线的每个点位做一次位移计算，计算后的首尾端点才可以用来生成曲线，以此创建管道，将所有管道依次连接起来

2. 端点都是三维向量



- [x] 检测模型对象下的动画=>播放动画=>单独旋转、`小范围移动`（tweenjs）
- [x] 配置sprite纹理（可配置普通纹理或自定义canvas纹理，`分辨率可配置`）

​	配置分辨率：

​	1.加载图片后转Base64==》调整Base64输出格式（调整分辨率）==》使用Base64图片加载纹理

​	2.minFilter/magFilter（适应精灵）





材质共享问题（默认共享材质的模型）

- [ ] 项目打包SDK

- [x] 图表渲染问题
- [x] 统计点线面信息
- [x] 材质共享 取出模型文件解析后的材质，后续添加的相同的对象都是用相同的材质对象（要不要用clone？）
- [x] 精灵（自定义canvas）自定义尺寸
- [x] 精灵（单色纹理共享）
- [x] 操作记录 （按每次记录分割数据）
- [x] 合并渲染情况下材质共享
- [x] 合并渲染但不共享材质情况下，无法绘制物体



解决了非合并渲染下材质共享问题



- [x] 合并渲染且材质共享情况下点击改变实体出错
- [x] 合并渲染且管道相连情况下的材质共享
- [x] 合并渲染且材质共享的情况下左键点击无法改变颜色

开放射线拾取、加载gltf模型、清空场景功能接口







合并渲染且材质共享情况下无法控制单个子对象是否渲染

- [x] 合并渲染且材质共享情况下视点控制器失效
- [x] 合并渲染且材质共享情况下视锥体控制器失效
- [x] SDK的接入
- [x] 管道首尾相连，合并渲染但材质不共享的情况下 线面统计出错、删除模型出错
- [x] sdk迁移过程中  更新视点球功能失效



保存所有内存 FPS信息，保存操作日志，渲染操作日志表格，渲染某一操作性能变化图表


操作日志（自页面打开开始：按时间保存所有内存与fps信息、点线面信息，保存所有操作信息：操作名称、操作时间、即时内存与FPS信息、点线面信息、操作内容{渲染参数}，选取某一时刻的操作后，截取前后一分钟的内存与FPS数据并输入到统计图）

表格展示操作记录（点击后展示该记录的详细数据，并渲染统计图）







日志：动作名称-时间段-性能变化记录-渲染参数



创建视锥体才会创建附属相机---附属相机需要在操作控制器时，实时更新附属相机的位置

视锥体首先创建---更新视锥体参数时删除原有视锥体，在创建新视锥体---



各个gltf模型的构成不一样，各个材质的



取出材质后再赋值，如何保证材质一一对应







转SDK版本：

管道相连



1. Detector的SDK版本的基础框架搭建
    文字标注、图文标注、卡片标注的性能分析
    模型标注、合并模型、模型动画、模型路径移动的性能分析
    气泡标注的性能分析
    线标注、管道标注的性能分析
    各种特效标注的性能分析：（点云、数字流动）
    场景进阶效果（如：背景透明、天空盒、、阴影、全屏特效等）性能分析
    对场景合并房间、合并矢量建筑的性能分析
    自定义视锥体范围控制模型加载的性能分析
    场景可点击物体数量和射线遍历射中对象的性能分析





问题：原有性能检测机制兼容性差，难以适应新的三维场景，重新编码使其适应新环境的工作量大

解决方案：

1. 针对原有性能检测器Detector进行改造，为scene.children添加代理，拦截数据的添加与删除操作，记录实时性能数据。

方案实施中遇到的问题：

1. 代理添加后，删除场景中的3维物体出现bug，~~猜想可能是因为代理导致this指向的变化~~，无法找到原因
2. 一次性对大量网格对象进行增删操作时会频繁触发拦截，可尝试用防抖解决





性能检测报告

|   标注名   |        数量         | 加载时间 |  帧率  |
| :--------: | :-----------------: | :------: | :----: |
|  文字标注  |        2000         |  573ms   |   46   |
|            |        5000         |  1213ms  | **20** |
|            |        10000        |  3886ms  | **10** |
|  图文标注  |        2000         |  714ms   |   60   |
|            |        5000         |  2532ms  |   30   |
|            |        10000        |  8420ms  | **14** |
|  卡片标注  |        2000         |  2107ms  |   60   |
|            |        5000         |  3063ms  | **12** |
|            |        10000        | 11598ms  |   -    |
|  气泡标注  |        2000         |  256ms   | **24** |
|            |        5000         |  792ms   | **13** |
|            |        10000        |    -     |   -    |
|   线标注   | 100（添加纹理贴图） |   42ms   | **22** |
|            |        2000         |  594ms   | **13** |
|            |        5000         |  1812ms  | **5**  |
|            |        10000        |    -     |   -    |
|  管道标注  |        2000         |  1358ms  | **20** |
|            |        5000         |  4316ms  | **7**  |
|            |        10000        |    -     |   -    |
| 轨迹线标注 |        2000         |  197ms   | **19** |
|            |        5000         |  741ms   | **10** |
|            |        10000        |  1572ms  | **6**  |
|  区域围墙  |        2000         |   40ms   |   60   |
|            |        5000         |  141ms   | **22** |
|            |        10000        |  193ms   | **12** |
|  滚动围墙  |        2000         |  3286ms  |   48   |
|            |        5000         |  8400ms  | **19** |
|            |        10000        | 17479ms  | **9**  |
|  圆圈旋转  |        2000         |   48ms   |   40   |
|            |        5000         |  110ms   | **16** |
|            |        10000        |  173ms   | **7**  |
|   扩散圆   |        2000         |   48ms   |   30   |
|            |        5000         |  115ms   | **11** |
|            |        10000        |  209ms   | **6**  |
|  圆桶扩散  |        2000         |  699ms   |   33   |
|            |        5000         |  1764ms  | **16** |
|            |        10000        |  3232ms  | **7**  |
|  圆桶浮动  |        2000         |  559ms   |   41   |
|            |        5000         |  1280ms  | **17** |
|            |        10000        |  2429ms  | **9**  |
|    火灾    |        2000         |  1186ms  | **6**  |
|            |        5000         |    -     |   -    |
|            |        10000        |    -     |   -    |





1. 逐步熟悉SDK加载各种标注的处理流程
    对第一步的分析结果，在现有sdk中整理出相应的优化方案
    在熟悉过程中可以分析各种标注有哪些不合理或者隐藏bug
2. 工具sdk的开发：
    接管机房sdk的升级与维护
    接管气泡标注聚类的升级与维护，后续考虑如何实现点云的聚类实现。
    其他小交互工具或者示例页的开发：
3. 【用于实现室内房间无遮挡显示室内设备模型的交互，整理相关细节说明】
    【用于切换白天与黑夜版本场景效果的交互，整理相关细节说明】
    【用于实现室内室外路径漫游的交互控制，整理相关细节说明】

3. theatrejs的工具的接入开发。
① 熟悉了解theatrejs的使用和相关应用场景
②核心功能开发：相机路径动画编辑，分镜编辑与管理。
③以独立工具与SDK相关接口进行扩展相机动画功能。





## 点聚合源码：

1. 实际渲染图片标注，聚合后用气泡标注替代

   问题：气泡标注内部数字为1 时应当渲染为实际的气泡标注

2. 三种marker: 多边形（）、气泡（显示范围内数字）、图片（实际要渲染的标注）

3. polygonMarker 标注的加载？？？

4. 在num为1 时不展示气泡标注，直接展示原始图片标注即可





## 地铁

- [ ] 更新具体区域的人流量
- [ ] 导入导出摄像头及区域数据
- [ ] 点击弹出摄像头信息，显示视频
- [ ] 在已有实体组中添加新区域 ，会出现新建一个组数据 而不是在原有基础上更新
- [ ] 线段跨越楼层时，模型无法跨越楼层

问题：没有办法删除指定线段





## 补给

- [x] 系统两侧、底部的边框按照设计稿进行优化调整
- [ ] 首次加载无动画
- [x] 右侧面板数据无法实时更新
- [ ] 

点击模型搜索所有对应的名称 将名称底下的所有暂存区数组取出，然后计算出最近时间点的目标物资类型的数据





点击中转区 和点击暂存区，如果没有搜到改时间点的物资数据，则中转区应该使用暂无数据 0箱， 暂存区应该用上盖物资的初始状态数量

实际上中转区和暂存区都属于

## SDK

场景：一个模型加载后，按顺序播放两组动画，假如前一动画的设置了clampWhenFinished = false，loop = true后一组动画设置为clampWhenFinished = true，loop = THREE.LoopOnce，（理想状态是：前一动画会循环播放，后一组动画，仅仅只播放一次，播放完成后会停留在最后一帧）但后一组动画在播放完之后会让整个模型都停止在最后一帧，而THREE.js原生动画播放器可以按照理想状态运行

猜想：可能是因为每次playAnimation时会生成一个动画播放器，前一个playAnimation执行时把该动画播放器的clampWhenFinished 设置为false 后面

SDK中必须执行动画后才可以生成原生的动画播放器

使用原生动画播放器后，设置loop失效  必须使用setLoop(true)

marker.o3d_.userData.actions.down



1.animations数组元素换成mixer动画播放器，



1.新增mixers动画播放器数组，用于存储当前的mixers动画播放器，对动画进行统一更新

2.



问题：使用playAminimation接口播放动画时，两动作不冲突，但是前一动作会在此过程中播放两次（第二次可能会倒放）

修改接口后，播放动画失效，~~可能是动画没有及时更新~~，更新方法生效了，但是mixers数组为空，所以依然没有得到更新

修改成功：

1、this指向问题

2、fadein，fadeout导致的动画权重weight变化，致使前一动画回放至开始一帧

3、option配置开启stopLastAction，来关闭前一动作，所以在多动画配合的使用场景下应当关闭stopLastAction

##### 新增接口:新增获取模型下所有动画的接口

##### 新增接口：针对单个动画进行进行控制

``````javascript
{
    name:"", // 动画名称
    cmd：xx, // 控制码（开始：0，暂停：1，继续：2，结束：3，下一帧：4，上一帧：5，倒放：6）
}
``````

功能测试：

- [x] 直接播放动画，
- [x] 播放指定时长
- [x] 播放次数
- [x] 延时启动动画
- [x] 播放倍速
- [x] 停留在最后一帧
- [x] 循环播放
- [x] 播放至指定帧
- [x] 播放完成执行回调

动画播放问题解决（延时启动startAt,干扰二次播放。r105版本threejs本身存在的问题）

以业务、功能需要为准，整合原有threejs API，重新整理为符合实际功能需要的





- [x] 动画播放速度（与持续时间冲突）
- [x] 动画倒放
- [x] 播放至指定帧（创建新的动画剪辑）



#### 优化现有模型movePath动作：

①优化现有movePath的第三人称的视角角度跟随效果。
②追加第一人称的视角配置
模式1：鼠标控制任意角度旋转朝向
模式2：基于模式1，在车辆朝前运动中，追加角度限制（目的：保持前方视野朝向，无法回头看运动对象）





##### 第一人称视角（orbitControls方案）：

原理：设置相机注视点，相机在围绕这一注视点的球轨上运动，只要注视点与相机的距离足够近，就可以实现类似于第一人称视角的效果。

1. 可更新相机焦点位置（与模型位置绑定）
2. 控制器更新无法更新相机位置，如果在update中循环更新相机位置，会导致视角的锁定（相机永远注视一个方向）
3. 参考代码中固定了注视点位置，相机也在该球轨运动，无需更新相机位置

问题：

- [x] 模型运动过程中，左键旋转场景时相机视角会回调至模型本身

  模型运动过程中旋转视角的话，会导致



##### 第一人称视角（PointerLockControls方案）：

开启后锁定鼠标，鼠标移动控制注视方向。

1. 无法控制相机位置，在update中更新相机位置无效



- [x] 浏览器模拟移动端场景中，触发触摸事件时出现异常，无法正常获取相机的欧拉角
- [x] 手机端浏览时，触发触摸事件时和点击退出时出现无法解析的错误信息。
- [x] 无法计算触摸起始点位
- [ ] 退出事件必须同时添加 touchstart、click才能触发
- [ ] 第一人称视角控制不自然
- [ ] 





##### 第一人称视角（FirstPersonControls方案）：

1. 可实现效果，观感差，操作性不好，容易晕。

重构movepath

tween 动画

鼠标剧烈晃动下模型会在视野丢失，但相机正常运动



movePath过程中加速问题：

使用TWEENjs方案使模型按路径移动

问题难点：

1.使用返回的options进行动态更改tween动画对象时，无法将time的修改落至实处

2.修改每次循环计算出来的p.time  将会在动画对象初始化之后，动画开始之前对动画进行修改（未生效）

3.在循环中修改动画对象的持续事件_durition

​		





## 深大-近接施工软件

需求分析、项目工期评估

1.施工数据导入

检测文件大小（0-5M）

文件数据存储 pinia

展示这个文件的表格

检测对应指标是否齐全

存在问题：

- [x] 如何检测对应指标是否齐全（与哪一份数据？）

- [x] 校验每份文件至少得绑定一个评估组
- [x] 评估组的绑定信息的存入 与读取
- [x] 默认选中所有评估组
- [x] 四个评价矩阵的写入
- [x] 时间序列的表头修正
- [x] 修改后的指标库写入



文件检查：是否多指标校验--施工类型校验--指标缺失检查





四元数（欧几里得长度）、变换矩阵、欧拉角互相转化

正余弦值的输入输出

空间变换中，矩阵的秩、迹、特征值、特征向量、点积





矩阵乘特征向量 = 特征值乘特征向量（特征值对应mat4的伸缩倍数）
$$
Av = λv
$$
变换矩阵的特征多项式

绕x轴旋转60度可表示为
$$
Q = cos（π/6）+sin（π/6）i+0j+0k
$$
~~欧拉公式的证明~~、四元数的解释，四元数、变换矩阵应如何转化





离屏渲染



















立方体嵌套（父子层层嵌套） 测试嵌套上限（射线相交）21

纹理参数、配置个数

嵌套：材质共享（）



group装载盒子（平级）上限 38





分析具体的模型的构造层次 转成 用group的平级装载形式

5k个发光图片标注fps 为15左右



正常渲染情况下：渲染三个模型时，性能表现下降  40-48

网格数:4608，面数：4243323，材质数：4608，贴图数：3570



模型处理后：渲染三个模型时 帧数为46-54













光照模型 - 四元数与欧拉角应用场景 - 地图瓦片切割与数据获取 - 数据格式管理（如何将格式文件加载到缓冲区？） 资源池管理



欧拉角进行插值计算时容易出现问题，进行球面插值时应该使用四元数



shader - 光照模型











对象025_11  对象025_3

对象025_17  对象025_66

对象025_16  对象025_65

对象025_18  对象025_59

对象025_19  对象025_58

对象025_20  对象025_56

对象025_22  对象025_54

对象025_27  对象025_46

对象025_28  对象025_42

对象025_29  对象025_37

对象025_31





模型压缩、模型审查工具、模型加载流程优化梳理、子mesh面片统计与手动分离





gltf-transfrom模型压缩

|    模型    | 顶点 | 面数 |     FPS     |
| :--------: | :--: | :--: | :---------: |
| 木棉树工厂 | -11% | -5%  | 提升5帧左右 |
|   工厂2    | -10% | -6%  |   无提升    |
|            |      |      |             |

注塑机模型无法被压缩





优化

ASTC纹理贴图压缩(舍弃jpg/png格式)





手动创建减面插件会减少23%的三角面、20%的顶点（尚未用上sharp）



开源节流





环境光（Ambient）= 反射率×光强 

L = K（反射率）×I（环境光强）

漫反射（Lambert）一个完全漫反射体上反射出来的光的强度同入射光与物体表面法线之间的夹角的余弦成正比

L = K × I × cosθ 



draco压缩后

| 模型  | 类型 | 顶点       | 面数 | 文件压缩率 | 说明           |                                                              |
| ----- | ---- | ---------- | ---- | ---------- | -------------- | ------------------------------------------------------------ |
| huowu |      | +3%左右    | -    | 90%        | 外观几乎无变化 | ![image-20240321143631987](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240321143631987.png) |
| huoti | 建筑 | -56%       | -55% | 95%        | 子mesh缺失严重 | ![image-20240321143709835](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240321143709835.png) |
| luone | 建筑 | 几乎无变化 | -    | 80%        | 外观几乎无变化 | ![image-20240321142901079](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240321142901079.png) |









draco适用范围



哪些东西容易丢失



转回105版本  测试draco压缩模型   并撰写模型详情

使用SDK加载draco，把模型文件放在`\\SERVER127\EsmapJsonData\test666copy1\model`下

疑问：在哪个步骤添加DRACOLoader

1.ESGLTFLoader内置 检查gltf扩展内容，检测到使用了draco扩展 自动添加DRACOLoader

2.modelLoadManager文件内 手动添加代码 进行添加draco扩展











加载方式：1.GLTFloader和DRACOLoader配合使用，初始化DRACOLoader后设置解析器路径，再导入至GLTFLoader，使用GLTFLoader.load加载

​		2.仅仅只用DRACOLoader.load









使用draco后 四边形面变形（同时三角面可能会变成四边形面）

顶点数据精度丢失（导致深度冲突）





流程



目标：

1.了解使用流程，把SDK创建的场景导入工具中，解决相机路径编辑，提取json中必要的轨道数据，使用sdk播放轨道



完成场景创建 完成相机与控制对象绑定

SDK镜头疑似被锁

创建动画播放类

控制相机路径动画关键帧，执行动画播放等功能





创建一个组件以表示当前镜头信息及鼠标点击的实体信息







注意：此插件无法旋转镜头，

相机路径动画编辑步骤：

1.





json文件的加密、文件读取时的数据转换（）



类初始化后创建滚动条播放，利用进度条控制动画播放

滚动条 （已有调整进度条的方法）





难点：如何在动画中应用贝塞尔曲线？

想法1：使用theatrejs原有的动画读取机制

问题:原有的json经过加密、压缩后，无法被原有的动画读取逻辑解析

想法2：js解析关键数据后使用tweenjs动画库播放该动画

问题：theatrejs中是以数组的形式应用贝塞尔曲线。tweenjs动画中使用函数的形式应用贝塞尔曲线。

数组反推为自定义函数的转换难度大，难以实现。



具体流程

导出json ====》自定义加密插件====(外部暴露)====》具体使用环节（自定义解密插件）====》解析成原json



默认动画帧率60帧 

播放进度与动画具体帧的双向绑定



问题：

设定相机rotation无效 ，无法在动画序列中体现：

调出扩展的小场景后，调整相机rotation生效，但在大场景中不体现，按此设定动画片段后，在大场景中依然不体现。

针对除相机外其他实体，设定rotation相关动画片段生效。







完成webpack相关针对性打包配置，完成theatrejs类打包。

探究路径动画编辑器中rotation动画编辑无效问题，完善theatrejs类的编辑逻辑，降低使用难度。



## 4.16

梳理优化sdk加载draco模型的全部流程。

梳理优化theatrejs的相机运动路径动画的编辑流程

优化gltf-transform的模型压缩配置规则。







走gltf-transform的模型压缩流程前后对比

| 模型名称         | 原模型大小 | 优化后 |
| :--------------- | :--------- | :----- |
| erciposuizhan-F1 | 75.1M      | 5.17 M |
| erciposuizhan-F2 | 27.2M      | 2.48 M |
| erciposuizhan-F3 | 21.8 M     | 2.61 M |
| erciposuizhan-F4 | 2.35 M     | 530 K  |
| erciposuizhan-F5 | 15.8 M     | 2.52 M |
| shiwai-1         | 49.0 M     | 1.11 M |



## 4.17

目标：在使用控制器控制相机变换时，相机参数变化实时同步到theatrejs的参数变化

或者直接写入序列

已完成



## 4.18

以第一人称控制场景。PointLockControl为基础



不以pointlock为基础 ，改造firstPersonControl的鼠标旋转部分。

改造原因：原有第一人称控制器控制精度不够，镜头不容易固定。

阅读源码。进行功能设计构想。



鼠标控制：

鼠标左键按下时，记录鼠标位置变化，根据鼠标位置变化控制相机镜头的旋转，并实时应用旋转量。

松开鼠标，停止控制镜头。





## 4.19

编辑相机路径动画序列demo。完善具体操作流程，根据实际出现的问题调整相关代码。

针对原有的firstpersonControls,改造鼠标控制逻辑，完成了视点控制与相机控制两种实现方案并进行对比优缺点，在实践中选出最佳方案。





## 4.23

将相机的rotation的变化值转化为角度表示。



问题：相机在转弯时会有异常偏转。

原因：转弯时，相机的rotation的xyz三个属性是同步变化的，实际上只需一个轴进行变换就可以完成旋转。

解决方法：录入相机转弯的关键帧时，只需要变化相应的轴即可完成转弯操作，其他两个轴变换的关键帧轨道可以删掉。



录入关键帧时控制器的选择。

在编辑器中提供所有的控制器选择，以便在编辑过程中顺利切换

1.mapControls（存在控制死角，不方便）

2.firstpersonControl（控制器精确度不够，镜头容易飘）

3.PointerLockControl（开启后锁定鼠标，类人物视角，存在死角）

4.第三人称漫游（控制小人在场景中移动，补充movePath的缺陷：移动过程中需要额外聚焦其他物体）

5.关闭所有控制器。

## 4.24

提供多个控制器以供动画序列编辑作者挑选。



esmap 挂载pointerlock后，出现问题  ：

1.如果从第一人称控制器切换到其他控制器时会出现错误

![image-20240424172641160](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240424172641160.png)

2.直接关闭地图控制器后出现大量错误

3.出现第一人称和地图控制器混合的问题

控制器切换问题。

切换后firstpersonControl丢失target



## 4.25

1.解决控制器切换时出现的混合控制、丢失target等问题

切换至pointerlock出现失控问题

## 4.26

- [x] 1.播放进度条问题
- [x] 2.完成打包（css合并）



Detector补充地图加载时间记录（用于记录优化地图之后的时间变化）。

## 4.28

动画序列编辑过程中应特别注意相机的rotation属性的变化，在正常场景运动过程中，X轴负责俯仰角，Y轴负责方向角（左右转向），Z轴负责翻滚角。如果发生异常旋转问题 应针对rotation进行相应编辑，以保持镜头稳定运动。

解决了打包过程中出现得一些问题。完成theatre类的打包

## 4.29

找现有大模型地图 - 内部模型文件压缩 - 加密 - SDK加载场景 - 比较压缩前后的场景文件和渲染加载时间



删除关键字眼、邮箱电话、版权许可、类关键字、控制台错误、警告、提示信息等  包括所有暴露在外的关键字眼

同步新版SDK的压缩模型加载功能，检测爱迪曼工厂场景性能表现。

根据现有文件与功能需求重新优化模型压缩流程。

## 4.30

完善、简化模型压缩流程，提供模型的批量压缩转化能力，

验证场景模型更新后的加载，

解决nodejs在操作文件时的权限不足问题。

开发针对动画序列编辑器的第三人称控制器功能设计。



## 5.6

人物模型、105版本胶囊体 八叉树插件缺失

**加密城市地图模型时需要该模型应该要有独立文件夹，室内地图模型不用有独立文件夹**

模型压缩与未压缩对比  加载单个模型

![image-20240506144237917](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506144237917.png)

![image-20240506144242668](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506144242668.png)

加载20次

![image-20240506160445878](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506160445878.png)

![image-20240506160450554](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506160450554.png)

正常加载：模型文件体积大、无需解压、文件加载耗时长

draco加载：模型文件体积小、解压时间长、加载耗时短

sdk中插入时间统计代码 统计draco解压缩时间

test2：luone29-gltf（100m） 仅加载1次

![image-20240506182423553](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506182423553.png)



![image-20240506182540708](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240506182540708.png)

**总结：**模型较小的情况下 正常加载与draco解压后加载两者耗时相近，模型文件越大 draco加载越快，以luone29-gltf为例 ，draco加载比正常加载快2s



比较模型压缩与正常加载的时间消耗，调整相关参数校准场景加载时间，给出后续实际应用场景的加载优化策略。

设计第三人称的总体功能，在原有第三人称控制器的基础上加以完善。

## 5.8

第三人称优化 

禁用鼠标平移、键盘控制移动、相机注视点与相机应同步移动 



​         debug模式、

截图功能

## 5.9

第三人称测试

问题：此时地图还未加载，且未创建图层。如何添加人物模型或实体到场景中？主场景scene对象



室外场景倾斜摄影数据性能测试



完成室内室外截图功能及截图分辨率倍率设置

测试城市三维场景添加draco压缩模型，并进行室外场景倾斜摄影数据性能测试，并输出测试报告

调试第三人称鼠标移动时对注视点和相机的控制



**加载draco模型（12M）：**加载速度优化。不会出现明显卡顿

**加载正常模型（95.9M）：**加载速度较慢，出现卡顿感，模型展示时机稍慢。



## 5.10

加载所有模型到城市场景中，测试场景加载性能表现：



共同点：加载时间长（7s-9s左右），加载过程中帧率较低，会有明显卡顿

**正常模型（463M）：**加载时间较长，加载过程中，帧率不稳定且不稳定的时间较长，控制场景时会有明显卡顿，体验感差

**加载draco模型（89.7M）：**加载时间比正常模型加载快，控制场景时会有卡顿，体验感较差。

部分模型的bin文件太大无法加密。可以先剔除bin文件，加密后再把bin文件加入。





针对目前模型优化流程运行较慢的问题，开启node多线程加速优化流程。

加载所有模型到城市场景中，测试场景加载性能表现，解决测试过程中出现的一些问题、

## 5.11

带宽控制（indexDB缓存开启）

| 带宽 | draco模型加载时间 | 正常模型加载时间 |
| :--: | :---------------: | :--------------: |
| 10M  |     1.8 分钟      |     1.5 分钟     |
| 20M  |       57.6s       |     1.0 分钟     |
| 50M  |      16.62s       |      18.95s      |
| 100M |      11.25s       |      14.93s      |



第三人称控制器  微调



SDK添加场景及压缩模型加载初始参数配置，完善和优化压缩模型加载流程，解决参数配置过程中出现的一系列问题。

## 5.13

- [x] movePath 的speedchange方法

- [x] 设置duration未生效、
- [x] 动画倒放未生效、
- [x] 动画的上一帧与下一帧问题
- [x] 动画暂停、



69. 线标注的曲线平滑控制问题需要更高自由度的配置。先确认smoth和curvature两个参数的实现算法，调试这两个参数是否满足定制业务效果的需求

    

确认情况: 粗线和细线曲率的实际展示效果不一样？

实际情况：**smooth属性设置后未生效、曲线更新函数异常。**



创建平滑曲线时无法应用smooth属性



检查线标注的曲线平滑控制问题，测试与确认smooth与curvature属性的实际执行情况。

纠正模型路径动画与关键帧动画控制机制，测试动画接口执运行情况。

完善压缩模型加载机制，并预定迁移至新版SDK。

添加第三人称控制器的控制实体绑定机制，实时同步target与被控制实体的朝向。



线标注性能问题比较大（添加纹理贴图后）。





## 5.14

mappicker 手指移开和手指移动的事件函数会同时触发 现有解决方式是计数区分 触发5次以上算作手指移动，没否则算手指移开事件。

更改触发条件 检测手指移动的距离，如果移动距离超过一定范围则算作手指移动事件。



- [x] mappicker用户触发条件出现异常，修正mappick移动端PC端的自适应触发逻辑，调试并更新mappciker接口内部功能。

- [x] 将模型动画、路径动画、压缩模型加载机制等相关改动同步到最新版SDK

- [ ] 优化raycastByCoord接口：返回射线射中的mesh序列指定子构件的坐标值



射线选中的物体序列  返回特定目标物体的坐标Y值

事前准备：加载模型后对于模型上某一子构件直接给予特定命名 然后用射线选中后返回该子构件的坐标y值

优化raycastByCoord接口：返回射线射中的mesh序列指定子构件的坐标值(传入目标mesh的name值)



## 5.15

原位置{
    "x": 12683385,
    "y": 2557812,
    "z": 6
}



{"x":12683475,"y":2557889},

​	openBuildingById接口调试，避免模型显隐动画妨碍后续室内模型展示,解决用户对于打开多个室内模型的需求。

​	

## 5.16

openBuildingById接口调试：添加地图配置参数，避免模型加载过程中的时间限制，达到连续加载室内模型的目的。

raycastByCoord接口优化，返回值添加模型的id与坐标值属性，并识别室内外模型。并将同步至最新SDk

## 5.17

modelLoadedAll接口优化：优化modelLoadedAll响应逻辑，解决用户反馈的相应时机不正确的问题。

raycastByCoord接口优化：设立父构件对象回溯机制，追溯整体模型的室内外归属。

## 5.20

raycastByCoord接口：完成室内外模型选中功能及其高度拾取。

新增分屏接口：

开启多相机分屏、分屏下点击后的屏幕坐标转换问题（ 交互、控制器）、对某一分屏添加遮罩层、

## 5.21

优化原有射线选取物体高度逻辑。

新建测试用例

开启分屏需关闭原有渲染器渲染



如果需要用控制器（使用控制器的前提是得分开渲染dom,实际上就需要重新梳理渲染流程 ）

不用控制器（需要 1.指针变换）

存在问题：第一栋建筑射线正常拾取地板，打开第二栋建筑后，射线仅能拾取室外地板

## 5.22

完成射线拾取

分屏渲染（控制器问题解决：控制器其中一个画面时会导致另外两个相机同时改变）

注意要点：

1.分别创建三个覆盖分屏的遮罩，

2.需创建3个相机、3个控制器，控制器绑定各自的遮罩dom和相机

3.分屏情况下的射线拾取需注意鼠标位置的计算

4.渲染器必须开启裁剪测试

5.遮罩层宽高响应浏览器窗口变化



完成双屏比较功能：

要点：

1.创建两个不同场景sceneL, sceneR

2.渲染器必须开启裁剪测试



- [ ] 创建基于nextjs/nuxtjs的项目模板

- [ ] shader

  

完成多机位分屏渲染功能，解决各个分屏的控制问题，以及分屏情况下射线拾取的坐标问题，留存并记录功能设计要点

完成双屏比较功能，解决开启双场景后仅有一个场景被渲染的问题，留存并记录功能设计要点

## 5.23

SDK迁移分屏功能

1.参数准备分屏大小位置及相机位置。

2.相应遮罩层、相机、控制器生成

3.分屏的逐帧渲染（包括渲染器、控制器）

新增接口：用户控制target的移动

modelloadedAll异常触发

指南针控件未能响应容器变化而改变位置

直接更改容器大小不会使指南针控件相应变化-----mapView.resize

更改浏览器大小会使指南针控件位置相应变化-----window.resize



分屏功能在迁移至SDK之前的功能设计

挂载模型加载标识，纠正this指向，解决modelloadedAll异常多次触发的问题

添加ResizeObserver示例监听外部容器宽高变化（解决指南针控件位置未能正确响应式更改位置的问题）

```js
const getParent = (obj) => obj.parent ? getParent(obj.parent) : obj.parent
```



优化moveTo函数 新增参数配置 方向、移动量（原有参数为二维坐标{x,y}）

新增接口：更简单一些

## 5.24

北斗的温度扩散热力图

完成moveByDirection接口：输入方向及距离即可完成视角移动，解决相机移动过程中相机y坐标异常抬升的问题、解决2D视图下移动方向不正确且无法正常连续移动的问题，同步城市地图、室内地图、2D视图、3D视图的动画播放效果



（同步2D视图与3D视图的移动效果）

两个问题：

开3D视图，相机俯视的情况下，镜头发生异常转动的情况

2D视图下，无法正常连续移动镜头

## 5.25

单场景解决分屏比较

实现分屏情况下手动调整分屏大小，分屏大小调整后同步改变控制器绑定dom的尺寸，以及射线拾取时的坐标取值问题，解决射线无法正常拾取物体的问题。

SDK分屏功能：创建MultipleViews类，适应SDK各场景要素的变动。解决了功能迁移后出现的一系列问题

移动滑块后滑块位置异常

相机投影矩阵未更新，3D内容比例异常



## 5.27

SDK分屏功能完善 解决控制滑块时滑块位置异常的问题、解决各个分屏画面显示比例不正常的问题

raycastByCoord新增支持底下模型选中

解决moveByDirection接口在相机俯视的情况下，镜头发生异常转动的情况





问题：第二块分屏无法控制而且画面不符合分屏情况

## 5.28

SDK 分屏功能完善：解决分屏后无法控制器第二块屏幕的问题、解决分屏画面比例不正常的问题，并同步至城市地图。调整分屏前后的控制器逻辑。解决退出后无法继续控制场景的问题



问题 退出后无法继续控制场景（瓦片加载插件报错）

使用显示层级隐藏物体

画面嵌套（位置 大小设置）



## 5.29

画面嵌套设置

SDK 分屏功能完善：解决分屏后的场景控制问题、城市场景瓦片地图加载问题、

SDK多屏对比功能：创建相关类，搭建该类功能基本框架

多个iframe协同展示，自由调整大小



## 5.30

多屏对比 

协助完成海底可视化示例分屏功能，以及分屏大小调整

修复地图hover事件需要点击才可触发的bug

完善多屏对比功能：实现渲染多个屏幕、完成多屏对比退出功能



## 5.31

协助解决海底可视化示例分屏功能在移动端无法获取关键dom节点的问题

协助完成移动端滑动并改变船首方向值、小窗口添加准星。

修复moveByDirection接口的点位拾取逻辑

完善多屏对比功能：



## 6.3

优化一次性打开多栋室内建筑时的动画播放机制，取消对用户的提示。

修复开启分屏功能后，控制器混乱的问题，解决两块屏幕调整大小时无法自适应调整大小比例的问题。



逻辑保存

```js
      if (i === 0) {
        // 采用原有相机
        let camera = that.map.mapView.camera;
        // 第一个视口使用原有控制器和相机
        if (that.map.options.mode === esmap.MapMode.City) {
          that.views[i].controls = new ESTileMap.ESTileControls(
            esmap.ESTileMap.tileMapView,
            that.views[i].layout,
            that.map
          ); // 针对城市场景的控制器(防止瓦片地图带来的影响)
          esmap.ESTileMap.tileMapView.camera.camera3D.controls =
          that.views[i].controls;

          that.map.resetControls(that.views[i].controls);
        } else {
          // 非城市场景下，使用原控制器的构造函数
          console.log(camera, "camera", that.views[i].layout)
          that.views[i].controls = new that.map.mapView.controls.constructor(
            camera,
            that.views[i].layout,
            // that.map
          );
        }

        camera.position.fromArray(view.eye);
        camera.up.fromArray(view.up);
        that.views[i].camera = camera;

      } else {
        // 第二个视口使用新的控制器和相机
        let camera = new THREE.PerspectiveCamera(
          view.fov,
          view.width / view.height,
          1,
          10000
        );
        // console.log(i, "camera", that.views[i].layout)
        that.views[i].controls = new THREE.OrbitControls(
          camera,
          that.views[i].layout
          // that.map
        );
        camera.position.fromArray(view.eye);
        camera.up.fromArray(view.up);
        view.camera = camera;
        that.views[i].camera = camera;
      }
```





问题：特效组件可能会对分屏产生影响。





## 6.4

确认并解决分屏功能的控制器失效问题

（城市场景的瓦片控制器问题？）



鼠标长按图片标注，标注未闪烁

框选没有显示框选内容



场景导航-路径规划报错



确认并解决分屏功能的控制器失效问题

修正长按鼠标的判断逻辑、解除对射线射中物体的类型检查，解决未响应鼠标长按图片标注事件的问题。

修改定位标注的初始参数赋值。解决场景导航-路径规划报错的问题。

MapPicker框选判定逻辑纠正，解决鼠标框选功能异常的问题。



## 6.5

室内分屏 测试moveTo和MovePath，cameraFlyTo的镜头锁定等功能

moveTo: 仅影响左视图 不影响右视图(方法执行后调整视口大小会出现镜头视角变动)

cameraFlyTo：仅影响左视图 不影响右视图(方法执行后调整视口大小会出现镜头视角变动)

点击滑块会导致左视图镜头晃动

movePath：

分屏性能测试。





测试室内分屏后各个镜头变换接口执行后的实际影响

优化框选与debugpicker的判定条件：解决点击事件触发时机异常的问题

优化SelectionHelper触发事件：解决移动端框选时无法正确显示样式的问题。





## 6.6

增加测试项：创建N个平面网格（分割数1x1即可），可选择basic和standard两种材质类型，然后你随便搜集一波256x256,512x512,1024x1024的图集，选择三种类型分辨率的纹理，测试threejs本身60帧能加载多少纹理资源



| 材质类型x分辨率 | 分辨率    | 上限（60fps） |
| --------------- | --------- | ------------- |
| 标准材质        | 256x256   |               |
| 标准材质        | 512x512   | 1800          |
| 标准材质        | 1024x1024 | 1300          |
| 基础材质        | 256x256   | 性能较好      |
| 基础材质        | 512x512   | 性能较好      |
| 基础材质        | 1024x1024 | 性能较好      |

 

1024分辨率的标准材质加载上限约在1300左右 如能成功加载，对帧率影响不大。

256分辨率的标准材质加载上限未知，在加载3000个之后对帧率影响大。

总结：对于加载标准材质而言，可以加载更多低分辨率纹理 以代替高分辨率纹理。（高分辨率即使加载数量不多 依然可能导致崩溃）低分辨率纹理加载速度也比高分辨率纹理快。



使用uuid的方式统计纹理的

SDK-Detector 创建纹理统计列表

统计每个模型的纹理数量和分辨率（分辨率由大到小）

注意map.controls 的替换

新增统计

## 6.7

分屏后控制器问题

movePath

优化分屏后控制器相关的镜头变换接口：完善cameraFlyTo在分屏情况下的功能实现。解决cameraFlyTo视角飞行过程中出现的问题。并完成相关功能测试



新增性能检测项：统计每个模型以及其材质下的纹理数量和大小详情。

## 6.11

改为gltf 名称、模型大小、每个贴图的文件大小

新增性能检测项：完成对已渲染的每个模型的材质贴图统计功能，完成对应数据的页面展示，设置全局响应拦截器，新增统计每个模型以及其材质下的纹理数量和大小详情。



## 6.12

分屏功能迁移

nodejs 脚本解决大小分析问题



完成分屏及cameraFlyTo接口功能迁移至SDK。优化相机位置传入参数类型，完善分屏后的射线拾取逻辑。

性能检测：优化全局响应拦截设置，优化ServiceWorker对本地静态资源的拦截配置。



模型文件夹注意

## 6.13

替换watchingList，优化raycastByCoord接口

优化分屏后的射线拾取问题，完善覆盖层的事件绑定

测试每隔 1s时间在地图随机拾取射线，并检查cpu负载情况

比较使用targetName 和不使用 两种情况下的cpu状况





测试 1s 在地图随机射，检查cpu负载情况

出现情况：执行test函数后，cpu负载由20%左右攀升到40-60%之间（如果场景在移动则cpu占用率越高），之后回落至20-30%，这一现象在2-3s内完成





比较使用targetName 和不使用 两种情况下的cpu状况

不用targetName情况：

## 6.14

cameraFlyTo存在问题：如果用getViewCenter取点后，cameraFlyTo只会飞一次

原因:主场景实际未发生变化，getViewCenter获取的是原有控制器的中心点，第一次执行时会获取到主场景的中心点，第二次再执行获取的中心点为实际上与第一次相同，所以第二次执行函数时不会发生任何事情，所以使用两次用getViewCenter取点的cameraFlyTo实际上第二次不会发生变化。



优化分屏后的滑块位置

参数值优化

原有分屏功能改造，重新设计传入参数、重新计算鼠标位置、ndc视口范围及裁剪坐标范围、cameraFlyTo控制对象优化。

## 6.17

分屏功能：完成垂直布局和水平布局情况下的拖拽改变大小的功能。解决拖拽后控制器互换的问题，解决拖拽过程中坐标计算的问题。

地图纹理分析：完成本地资源文件的读取，输出本地图片文件和主资源文件占用空间大小

## 6.18

完成SDK版本的地图纹理分析。完成本地资源文件的读取，输出本地图片文件和主资源文件占用空间大小与读取的纹理一一对应，完成资源打包并上传

## 6.19

tileService.targetAndBuildingList中并没有收录目标建筑



## 6.20

目标：是纹理与贴图分辨率以及bin文件导致加载速度变慢。

饼状图数据完善

磁盘用量图：

纹理分辨率

**纹理大小**



完成纹理数据分析报告的编写。

针对模型子构建的bin资源大小进行排序展示图表。

完成bin文件、图片文件、gltf文件资源占用情况的饼状统计图。

完成图片纹理的文件资源占用情况的矩形树图，完成文件



图片名称带上路径

点击复制文件夹名称

## 6.21

突出纹理占比



完善bin文件、图片文件、gltf文件资源占用情况的饼状统计图。

完善图片纹理的文件资源占用情况的矩形树图，优化矩形树图的区块颜色。

重新修正模型纹理分析报告，突出纹理占比。

新增贴图路径，点击复制文件夹名称。









图片：拷贝一份地图数据，保留格式，调整分辨率不大于1024

显示效果对比，资源占用与性能对比。

针对优化的纹理位置进行截图对比



- [x] 性能检测器（纯js）
- [x] 相机路径动画
- [x] nodejs模型优化器
- [ ] shader



编辑分屏接口文档说明，编写问题及回复

完善nodejs多线程优化3d模型，实现加速模型处理进程。

完成图片处理功能。优化图片尺寸，降低资源占用。

测试raycastByCoord，调试相关流程。



## 6.25

导航箭头shader

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240626164537136.png" alt="image-20240626164537136" style="zoom: 67%;" />

##### **问题1**：shader呈现的效果在整个屏幕中固定不动，控制场景作旋转平移等变换之后，shader效果不会固定在目标物体上，应该怎么解决？

**回答**：你的问题是由于你在fragment shader中使用了`gl_FragCoord`来计算纹理坐标，这会导致你的shader效果固定在屏幕上，而不是固定在目标物体上。当你旋转或平移场景时，目标物体的位置会改变，但shader效果的位置不会改变。

要解决这个问题，你需要使用物体的纹理坐标，而不是屏幕坐标。你可以在vertex shader中传递纹理坐标到fragment shader，然后在fragment shader中使用这个纹理坐标来绘制你的效果。

以下是修改后的代码：

```javascript
function getShaderMaterial() {
    const shader = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            mouse: { value: new THREE.Vector2(0.0, 0.0) },
            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        },
        vertexShader: `
            varying vec2 vUv;
            void main(){
                vUv = uv;
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0 );
            }
        `,
        fragmentShader: `
            varying vec2 vUv;

            float circle(vec2 uv, vec2 center, float radius) {
                float dis = distance(uv, center);
                return smoothstep(radius - 0.01, radius + 0.01, dis); 
            }

            uniform float time;
            uniform vec2 mouse;
            uniform vec2 resolution;
            void main(){
                vec2 uv = vUv;
                vec3 color = vec3(0.0);
                vec2 center = vec2(0.5);
                float radius = 0.1;
                float c = circle(uv, center, radius);
                color = vec3(c);
                gl_FragColor = vec4(color, 1.0);
            }
        `,
        side: THREE.DoubleSide,
    })
    console.log(shader, 'shader');
    return shader;
}
```

##### **问题2**：如何在shader创建的材质中绘制文字？

**回答：**

​	在WebGL中，直接在Shader中绘制文字是非常复杂的，因为Shader主要用于处理图形和图像，而不是文字。通常，我们会使用一种叫做文字纹理的技术来在WebGL中显示文字。

​	文字纹理就是将文字渲染到一个2D画布上，然后将这个画布作为纹理传递给Shader。在Shader中，你可以使用这个纹理来在你的物体上显示文字。

​	以下是一个简单的例子，展示了如何创建文字纹理并将其传递给Shader：

```Javascript
// 创建一个2D画布
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// 设置画布的大小
canvas.width = 512;
canvas.height = 512;

// 设置文字样式
ctx.font = '48px serif';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// 在画布的四个角绘制文字
ctx.fillText('左上', 128, 128);
ctx.fillText('右上', 384, 128);
ctx.fillText('左下', 128, 384);
ctx.fillText('右下', 384, 384);

// 创建一个纹理
const texture = new THREE.Texture(canvas);

// 更新纹理
texture.needsUpdate = true;

// 创建一个ShaderMaterial
const shader = new THREE.ShaderMaterial({
  uniforms: {
    time: { value: 0 },
    mouse: { value: new THREE.Vector2(0.0, 0.0) },
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    textTexture: { value: texture },  // 将纹理传递给Shader
  },
  // ...
});
```

​	然后在你的fragment shader中，你可以使用这个纹理来显示文字：

```glsl
uniform sampler2D textTexture;

void main() {
  vec4 textColor = texture2D(textTexture, vUv);
  gl_FragColor = textColor;
}
```

​	在这个例子中，我们首先在一个2D画布上绘制了文字，然后将这个画布作为纹理传递给了Shader。在Shader中，我们使用了`texture2D`函数来从纹理中获取颜色，并将这个颜色设置为了像素的颜色。

​	注意，这只是一个基本的例子，实际上你可能需要更复杂的代码来正确地定位和缩放你的文字。此外，这个例子假设你的物体是一个平面，如果你的物体是一个立方体或其他更复杂的形状，你可能需要更复杂的代码来正确地映射你的纹理。



##### 问题3：绘制圆形的函数返回值为float，如何理解浮点类型的圆？

**回答：**在shader中，绘制图形通常是通过计算每个像素点的颜色来实现的。对于一个圆形，我们通常会计算每个像素点到圆心的距离，然后根据这个距离来决定这个像素点的颜色。

在你的代码中，`circleLine`函数返回的是一个浮点数，这个浮点数表示的是当前像素点到圆心的距离与圆的半径之间的差值。如果这个差值在-0.01和0.01之间，那么这个像素点就在圆的边框上，函数就会返回一个非零值；否则，这个像素点就不在圆的边框上，函数就会返回0。

这个浮点数的值可以用来决定像素点的颜色。例如，你可以将这个值直接用作像素点的颜色，这样圆的边框就会有一个渐变的效果；或者，你可以根据这个值是否为0来决定像素点的颜色，这样圆的边框就会有一个固定的颜色。

所以，这个"浮点类型的圆"实际上是一个对每个像素点的颜色进行计算的函数，而不是一个真正的圆形对象。





- [ ] 绘制导航箭头shader：绘制外围圆环，及四周文字，绘制外围有色圆弧
- [ ] 测试SDK3.1版本升级后的百度地图、高德地图跳转室内三维场景示例
- [ ] 

## 6.27

SDK3.1Demo测试记录：

- [ ] 模型拾取示例（特效插件问题）

- [ ] 控制图层显示/隐藏示例（特效）

- [ ] 热力图应用实例（热力图应用未生效）

- [x] 模型沿路径移动

  MovePath过程中四元数插值问题、运动过程中模型不显示、镜头正常跟踪，无法确认是否符合正常情况

  已解决

  场景缩放后会导致移动过程中的模型消失（模型标注的showLevel问题？？？）

- [x] 模型旋转出错（已解决）

- [ ] 

SDK3.1 worlddemo测试记录：

- [ ] 点击百度地图、高德地图跳转城市三维场景示例 baiduDemo.html （底图插件）		![image-20240627153536611](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240627153536611.png)

- [ ] 基本三维场景示例 basic.html (特效文件问题)

  ![image-20240627143537242](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240627143537242.png)

- [ ] 
  controller-inertia.html （底图及特效插件）![image-20240627153647187](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240627153647187.png)


- [ ] 三维场景手势控制 controller-switch.html (同上)

- [ ] 坐标转换示例  coordTransform.html（同上）

- [ ] 模型拾取示例   event-nodeclick.html（三维场景 esmapcitydemo 请求失败、底图及特效插件问题）

- [ ] 三维场景飞行示例 flyTo.html（底图及特效插件问题）

- [ ] 获取三维场景范围  mapBound.html （三维场景 esmapcitydemo 请求失败、底图及特效插件问题）

- [ ] 三维场景配置选项 mapConfig.html （三维场景 esmapcitydemo 请求失败、底图及特效插件问题）

- [ ] 跳转示例  redirection.html （三维场景 esmapcitydemo 请求失败、底图及特效插件问题）

- [ ] 点击三维场景自动截图示例  screenshot.html （三维场景 esmapcitydemo 请求失败）

- [ ] 控制图层显示/隐藏示例 showLayerByControls.html （三维场景 10005 Liscense 文件错误）

- [ ] 上下滑动切换楼层  slide-changeFloor.html（ESMapError⛔: 主题文件请求错误: 1004;）

- [ ] 切换背景示例 switchBGColor.html （三维场景 esmapcitydemo 请求失败）

- [ ] 切换三维场景显示示例  switchMap.html （三维场景 esmapcitydemo 请求失败）

- [ ] 切换主题示例  switchTheme.html （三维场景 esmapcitydemo 请求失败）

- [ ] 三维场景主题样式示例 tileBuildingStyle.html（样式1与样式2展示效果差不多？？？）

- [ ] tileRouteStyle copy.html （特效及底图插件出错）

  ![image-20240627151804130](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240627151804130.png)

- [ ] tileRouteStyle.html （特效）

    ![image-20240627152028113](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240627152028113.png)

- [ ] tileThemeEdit.html （特效文件缺失）![image-20240627152413088](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240627152413088.png)



测试SDK3.1线上室内地图的功能示例的实际存在问题、并记录相关测试结果与出现的问题。

解决模型标注的MoveTo、MovePath、rotateTo过程中的四元数更新问题

更新视锥体frustum个别方法的实际应用



同步2.28之后的SDK更新代码





vue3demo无法正常运行

esmap.ESEventDispatcher未注册该API





## 6.28

优化MoveTo接口：新增高度参数支持、修正接口变量名称

同步4.22-5.20SDK更新代码



## 7.1

抽取逻辑：在线路上生成人物模型并朝指定方向移动，（人物间距、人物数量、模拟真实情况、）

接受点集作为参数





同步5.21-6.13SDK的提交代码。





## 7.2

场景中的人群加载的性能测试（尽量符合真实情况）



视锥体/视点控制的方式进行性能优化

webgl  shader方式进行优化



抽取逻辑：在线路上生成人物模型并朝指定方向移动，（人物数量、模拟真实情况、）接受点集作为参数.整合上层及底层逻辑，并进行功能测试。

同步6.13-7.1SDK的提交代码。



## 7.3

室内场景功能案例：

1. 三维场景常用功能：（多边形重新计算uv的问题） **解决**
2. 热力图：shader计算问题
3. 切换主题：文件请求错误
4. 普通标注：点击添加图片标注按钮 点击无效
5. 定位标注进阶功能：更新角度、显示/隐藏箭头按钮点击无效；显示定位范围 点击出错（无法查找到Geometry的顶点属性： **解决**）
7. 电子围栏（无法查找到Geometry的顶点属性： **解决**）
8. 多边形标注特效（无法查找到Geometry的顶点属性： **解决**）
9. 模型特效：添加模型边缘发光按钮点击无效
10. 轨迹线特效：无法添加轨迹线特效
11. 点云线特效：
12. 区域围墙特效：（特效组件问题）



完成6.13-7.1的新版本SDK代码提交同步，测试SDK3.1线上室内地图的功能示例的实际存在问题、搜集并记录相关测试结果与出现的问题，并逐步解决各个问题。

编写符合真实情况的数据进行地铁人流仿真的性能测试。

## 7.4

对地铁人流仿真进行性能测试，并给出后续性能优化策略

测试SDK3.1线上室内地图的功能示例的实际存在问题、搜集并记录相关测试结果与出现的问题，并逐步解决各个问题。

修复多边形标注uv计算异常的问题。



## 7.5



计算路径点

打开所有建筑 测试加载时长。



完善模型材质统计列表与统计图组件展开模式。

新疆能源 项目:

测试打开一二号车间所有建筑的加载时长。

优化模型中的图片分辨率与大小

针对地铁人流仿真测试movePath、moveTo与模型动画的执行性能



## 7.8

优化模型压缩、加密流程，

新疆能源 项目:

测试打开一二号车间所有建筑的加载时长。

优化模型压缩、加密流程，、优化模型本地图片分辨率大小控制、提升场景模型加载速度





## 7.9

当前版本SDK同步draco模型加载机制

参与讨论体育场人流仿真的技术实现和细节问题。

合理



GHTX-MK016:模型问题，无法加载



## 7.10

完成路径点集的合并与计算，完成座位区块点与疏散路线的连接。

完成生成人物模型，完成模型沿路径移动

解决人物行走路径与实际路径不符合的问题。

## 7.15

添加疏散模拟仿真加载进度条

解决点开建筑之后 无法正常进行疏散模拟仿真的问题。

新疆广哈测试模型建筑打开时间

## 7.16

优化进度条加载时的显示效果，

使用webworker优化人物行走路径数据计算性能

优化模型纹理统计逻辑，简化使用方法

## 7.17

worker 每10s，worker返回所有人坐标。统计所有时间

更换为点云加载

分散地铁公交人流：6 : 2 : 2

## 7.19

优化webworker数据推送格式，主动清除每次通信的临时变量，优化内存控制。

优化人员每次步进数，调整每次人员的撤离数。删除部分主页UI控件

解决人员在移动过程中突然消失的问题、优化报告弹出时机，人员疏散算法优化





## 7.23

marker3D的包围球？

## 7.25

解决第三人称控制器中目标标注与相机移动不同步的问题

解决阻止默认行为带来的报错问题

取消第三人称控制器的原有物理特性（重力加速度控制）。

增加运动惯性相关逻辑

增加模型关键帧动画缓动设置。

问题：仅能在平面移动

## 7.26

四轴碰撞检测（前后左右方向上的射线检测）

人物动作的过渡（threejs示例）







## 7.29

问题：目前关键帧动画从  `this.instance.mapService.modelStore[this.controltarget.model];`取出

该接口实际使用中无法获取关键帧动画。

首次执行动画无效

长按前进后放开按键，会出现动画一直执行的问题。



解决首次执行动画无效的问题

增加第三人称控制器的射线碰撞检测机制。

优化第三人称接口初始化逻辑。完善初始控制目标的设置





人模式

车模式





## 7.30

无法获取射线检测结果



整理相机动画剪辑工具与播放器相关项目至gitlab

## 8.1

完善第三人称控制器的行人、车辆模式

使用TWEEN动画库代替原本淡入淡出机制

测试相关逻辑机制的切换、优化第三人称启停机制

## 8.2

解决在第三人称模式下切换模型后关键属性丢失的问题

解决切换模型后的关键帧动画无法获取的问题

解决模式切换时会改变模型的位置的问题

整理相机动画剪辑工具与播放器相关项目

缺点：切换成车辆模式后，车辆停止运动但动画播放不会停止



注销时应销毁原有实例

实例注销时的切换控制



## 8.5

优化原有碰撞检测的逻辑，提高碰撞的检测成功率。

增加相机上下方向上的碰撞检测机制，优化相机抖动的现象。

优化人物模式下的后转方式。



指定经纬度范围 获取范围内的高程数据

加载时间（获取数据的时长）



## 8.6

截图接口纠正相机姿态的调整

截图过程中去除compass指南针控件

完善上层截图工具针对整个场景的截图合并功能。





当前视口范围内截取100*100的小图

用当前视口的尺寸（墨卡托）为标准小图，用指定的横纵范围去计算每行每列应包含多少个标准小图

如果当前视口以墨卡托坐标计算的范围很小，那么需要截取很多小图

如果当前视口以墨卡托坐标计算的范围很大，那么需要截取的图片就很少

测试 instanceMesh性能 146版本



## 8.12

1. 具体截图会受窗口比例影响，即使输入参数情况相同。
2. 全屏情况下无法截全
3. cameraFlyTo每次的输入参数会影响每一次的截图结果（相机起始位置影响截图结果）、moveTo
4. 输入参数调试比较困难
5. 





完善上层截图工具针对整个场景的截图合并功能，优化应用过程中的参数控制。

测试instanceMesh等几个加载接口在实际渲染中的表现

阅读threejs有关并行计算的



## 8.13

fadeIn fadeOut



迁移 webgl-instance-morph示例

测试射线选中、单个物体的位移旋转变换、显隐等问题



## 8.15

更新R146版本中部分shader切片代码，去除部分老旧shader

更新R146版本中部分有关蒙皮缓冲数据处理逻辑。



## 8.16

重新确定shader着色器的纹理采样精度

新增颜色矩阵计算接口

重新编排WebGLRenderTarget渲染目标对象的构造逻辑

纠正GLTFLoader中色彩空间配置





SDK的instanceMesh测试、

## 8.19

第三人称优化问题

1.安全距离限制鼠标缩放，控制器控制逻辑不自然。

## 8.20

优化第三人称控制器车辆模式下 控制目标无法正常转向的问题。

优化第三人称车辆模式的操控手感，增加操控时的启停缓动。

测试SDK3.0中的instanceMesh



## 8.23

instanceMesh的子元素的变换由其矩阵决定，不通过position、rotation等属性体现、如果需要改变其矩阵的话，应该提前计算好整个mesh 的matrixArray，然后通过tween动画的update回调中设置每个子mesh的矩阵



ES3DMarkerGroup接口设计要点：

1.构建instanceMesh 实现性能优越性。

1. 获取模型几何数据：geometry

2.动画更新：使用tween动画更新每个子mesh 矩阵



## 8.26

ES3DMarkerGroup接口设计难点：

​	各类模型构造与形态各异，构建instanceMesh需要提取geometry与对应的材质

1. 嵌套层级：多层mesh嵌套下如何提取几何顶点数据并且不会影响其本地矩阵？是提取上层父级mesh的几何顶点数据就行，还是需要提取基层mesh的集合顶点数据？

2. 提取出所有几何顶点数据与其对应的材质后，是一次性转换为instanceMesh还是每个单独转换为instanceMesh？

   

   **理想做法：**应该吧所有的顶点数据糅合在一起，单次处理成一个mesh（剩余的材质如何处理？如何保持原有矩阵变换？）



完成实例网格的运动动画逻辑与功能创建

测试SDK3.1新功能在实际项目中的表现

解决构建实例网格时顶点数据与材质对应问题，解决实例网格组装后的

## 8.27

性能检测器Detector：增加多边形标注相关检测项，增加渲染排序开关，测试渲染排序对性能的影响。

调试构建实例网格后矩阵变换问题。

优化实例网格构建机制，优化参数输入，降低复杂性。

## 8.28

测试在线体验的示例代码无法在edge浏览器运行的问题

测试城市三维场景多次F5刷新情况下内存泄漏的情况

优化原本平面图绘制类逻辑，裁剪绘制结果，输出房间平面图及阴影。



## 8.29

调试实例网格构建流程与具体机制，探究实例网格构建时机，优化ES3DMarker加载机制。



## 9.2

场景样式编辑工具

1.编辑模式下，需不需要展示实时修改预览（需要获取场景内所有标注，并针对性修改）

2.传入图层、根据传入图层展示编辑控件



场景样式编辑工具:

1. 建设场景标注基本样式类，分读取和编辑两大模式。

2. 设置实时场景标注效果修改后的预览。

3. 提供编辑后的json导入导出、读取解析功能。
4. 解析场景所有标注，批量修改标注效果

## 9.3

去除boxpicker框选时的蓝色框线，并添加相应控制项

解析场景所有标注，批量修改标注效果

配合lil-gui提供图形化编辑界面，针对标注类型提供对应的编辑组件





## 9.4



配合lil-gui提供图形化编辑界面，针对标注类型提供对应的编辑组件

解析场景所有标注，获取标注并修改对应标注样式

保存对应的样式json数据，提供导出接口

## 9.5

部分属性修改不了

浮动点特效颜色、

围墙特效的墙高、发光、



修改时重建对应标注。（颜色除外）

读取json（区分json是由用户输入还是由开发者控制）解析。





实时修改标注属性，并同步展示修改效果。

针对特效标注详细解析其属性及修改方法。

针对目前项目工具中需要注意的点及疑难点进行了讨论，形成了相应的解决方案。

## 9.6

第一次修改高度会出现深度冲突问题、

第二次修改会出现无法删除的问题（初始化时传进来的marker已经被删除、无法被删除第二次、）

问题：循环无法统一修改marker配置（每次修改配置后只会有个别marker发生改变）

递归设置



解决标注重建时会出现深度冲突的问题。

解决第二次重建标注时发生的无法删除的问题。

完成标注重建方法的逻辑梳理，用防抖方法禁止触发多次



城市

拦截部分模型加载-添加至延迟加载队列-主动触发加载 (延迟加载模型队列)



## 9.11

协助百色机房项目室外和室内渲染效果测试，整理下资源优化需求与方案

测试模型渲染流程，拦截并存储部分模型进行延迟加载

优化原有加载流程，节省部分性能快速加载外部模型



## 9.12

解决延迟模型加载队列加载时产生的资源不足问题

针对模型按楼层按缩放层级分类、添加模型懒加载队列控制参数并添加相关控制逻辑

依赖场景缩放事件优化原有资源加载流程，节省部分性能快速加载室内模型





延迟加载流程迁移至进入modelStore之后

进入modelStore之后 与 模型加载到场景之前 控制延迟加载流程（**存在疑问**）

modelStore中的模型加载到场景的相关加载接口会在每一帧中反复调用，如果在这一个逻辑中添加延迟加载流程可能会导致**性能问题**



## 9.13

由preFetchModel3D加入至modelStore，

每一帧执行checkIfNeedLoad是否可以加载，进入loadExist流程



## 9.19

广哈：模型加载不成功导致modelLoadedAll事件不触发，如何强制使模型加载成功



每次室外模型加载完成后都会触发modelLoadedAll事件



室外模型加载完成触发一次、室外建筑加载完成之后室内模型全部加载之后又触发一次



如果存在没有加载完成的模型的话，应该强制加载（加快加载进度）然后主动触发modelLoadedAll事件



频繁进行检查是否加载完成，每次检查时携带强制更新当前视图。





如果模型加载失败，是否会影响openbuildingbyid

## 9.23

调试百色机房项目模型加载逻辑，并测试相关代码

调试raycastByCoord接口返回值问题，测试raycastByCoord射线高频拾取性能。测试高频率线段绘制性能

继续开发行政区域外轮廓阴影纹理绘制工具中对于原始数据的处理与自适应逻辑的调试





探究在低性能终端上如何避免在模型没有加载完成的前提下触发modelLoadedAll事件，调整室外建筑模型全部加载的检查条件，并测试相应的触发时机与实际效果。

审查原有室内模型加载流程，重新调整室内模型加载流程中单一模型的加载逻辑

## 9.25

modelLoadedAll事件仅能触发一次、不能触发太早、





## 9.26

模型加载失败情况下依然要触发modelLoadedAll事件

调整modelLoadedAll事件触发时机、调整modelLoadedAll相关接口的触发与检测筛选条件，延后该事件触发时机，解决modelLoadedAll触发太早及在某种视角情况下无法触发的问题



30个标注实时更新位置



## 10.8

模型加载管理：添加室内楼层中多模型分批加载的逻辑，优化延迟加载队列加载完成的检查逻辑，并提示触发l懒加载完成事件

模型分类逻辑重新整理新增rank等级划分条目以配合分批加载。



百色机房二楼机柜模型加入至 toAddQueue加载队列 toAddQueue的加载流程

疑问：toAddQueue队列的加载逻辑与流程不明确



checkLazyLoadedComplete目前存在触发问题



待处理：室内地图showLevel与模型加载等级rank之间的换算（统一）问题



延迟加载流程迁移至进入modelStore之后

进入modelStore之后 与 模型加载到场景之前 控制延迟加载流程（**存在疑问**）

modelStore中的模型加载到场景的相关加载接口会在每一帧中反复调用，如果在这一个逻辑中添加延迟加载流程可能会导致**性能问题**



## 10.9

换算出目前像素单位与墨卡托坐标体系比值，

解决行政区域轮廓阴影绘制工具线段绘制及阴影显示问题，调整相关绘制逻辑已达到预期绘制效果

调整绘制逻辑，防止出现阴影绘制后被裁切的问题

解决绘制的结果图形宽高比例无法适应目标标注的问题。



目前存在问题：宽高比例无法完全对应



问题：

始终存在偏移问题

更换准备好的图片之后，乘以计算好的宽高比值也无法符合预期效果





叉乘判断内外与左右 ？

点加上点为什么说是中点？



## 10.10

完善输入数据处理逻辑，按照输入数据分批次在子画布上绘制目标轮廓，并合成最终绘制结果，解决绘制结果的宽高比例与预期比例不一致的问题

解决图案绘制后出现的白色边线问题

计算在增加边界阴影空间后贴图时所需扩充的宽高



完善标注更新插件:轨迹线标注、卡片标注相关配置项重设

